# Day 1



## 基础定义

+ 图：一个有序二元组 *(V, E)*，E是顶点集合，E是边集，E  V * V



```c++
typedef pair<int, int> pii;
int n, m, s, d[MAXN], vis[MAXN];
vector<pii> g[MAXN]

...

priority_queue<pii, vetcor<pii>, greater<pii> > pq;
d[s] = 0;
for (int i = 1; i <= n; i++)
{
    int u = 0;
    for (int j = 1; j <= n; j++)
    {
        if (!vis[j] && d[j] < d[u])
            u = j;
    }
}
```



## Contest



### T1-Train

+ [Question_Web](http://www.xmoj.tech/problem.php?cid=3752&pid=0)

```abc
问题 A: 训练
输入文件: train.in   输出文件: train.out   
时间限制: 1 Sec  内存限制: 256 MB
提交: 1  解决: 1
[提交][状态]
题目描述
马上要出征奥运了，小明决定再和 n 个人训练以提高经验值。但由于时间有限，最多只能训练 t 分钟，所以他可以选择一部分人来训练，每个人的训练价值由一个三元组 (a, b, c) 组成，表示如果小明在第 x 分钟和这个人训练，他需要训练 c 分钟，会得到 a - (x + c) * b 的经验值。

小明想知道他最多可以得到多少经验值。

输入
第一行一个正整数 ，T表示数据组数。

对于每组数据，第一行为两个正整数 n 和 t，表示跟和小明训练的人数和小明的训练时间。

接下来 n 行，每行三个正整数 ，表示每个人的训练价值，含义见题面。

输出
每组数据输出一行，一个整数表示小明最多能得到多少经验值。

样例输入输出
样例输入 #1复制
1
4 10
110 5 9
30 2 1
80 4 8
50 3 2
样例输出 #1复制
88
样例说明 #1
第 0 分钟和第二个人 (30, 2, 1) 训练，得到经验值 28；再和第一个人 (110, 5, 9) 训练，得到经验值 60。

数据范围
20% 的数据：n <= 10

50% 的数据：n <= 18

100% 的数据：1 <= n <= 1000, ai <= 10^6, 1 <= ci <= t, 1 <= t <= 3000

保证 n >= 200时 ，T <= 5 其他情况 T >= 10。

保证每个人贡献的经验值到训练结束都不会变成负数。
```



+ 题解 [Website](http://www.xmoj.tech/problem_solution.php?cid=3752&pid=0)

  ```abc
  首先，假如我们已经确定了要跟哪些人训练，按什么顺序训练最好？
  
  假设已经确定了要训练的  个人，某一个方案中训练的顺序是 ， 那么对于任意的相邻两项 ，考虑交换这两项的顺序，是否会变得更优。交换相邻两项，只会对这两个人的贡献有影响，对其余的人 不会产生影响。
  
  如果不交换这两项，损失的贡献是 ，如果交换这两项，损失的贡献是 （是一个常数）所以只需要判断是否 。如果此不等式不成立，那么应该交换这两项。对上式移项得 
   
   
  。所以对于一个确定的训练集合，训练的最优顺序只与每个人的 
   
   有关，按这个比值排序从大到小训练。
  
  于是，我们先对所有的人按照这个比值进行排序，接下来只要按照排好的顺序选择与哪些人训练就可以了。
  
  这相当于一个简单的“背包问题”，使用动态规划来解决。 表示恰好用了  分钟的最高经验值。状态转移方程为 。
  
  最终答案是  
   。
  ```

  



### T2_Fish

**一条鱼出渔网后回不来**🐟

线段树维护网内最大x，y，sum



### T3_Tree

```
Purfer/Prufer 序列
```

